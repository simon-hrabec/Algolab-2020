# Clues - solution
Clues is a pretty problem that I liked. It requires a bit of thinking about the problem, little theory and adequate level of coding.
- Understanding the problem
- Basic approach
- Bipartite graph
- BFS coloring
- The edge case

## Understanding the problem
Before solving the problem it is important to properly understand the problem. The problem does not ask if Holmes and Watson can communicate, but if they can communicate while there is no interference in the whole network (even thou this interference would not affect them).

## Basic approach
First we need to check if there is no interference in the network. If we detect some we can discard all the following queries and print `std::string(clue_count, 'n')`. If there is is no interference we get a network with some connected components. Holmes and Watson can communicate if they are close enough to each other to communicate directly or they are close enough to the same connected component. Note that we can get interference by 2 ways - first is if there are more than 2 stations that are close enough to each other (so they all see each other). And the second one can occur even if there is not "local" interference - if there is a chain of stations that can communicate with each other of an odd number then still we cannot assign them different frequency ranges to avoid interference.

## Bipartite graph
To verify there is no interference we need to check if the graph of the possible connections between the clients forms a bipartite graph. This can be also interpreted as a checking if the graph is 2-colorable - coloring the graph with 2 colors such that no 2 connected vertices have the same color. This sounds easy until you realize we do not have explicit representation of the graph. We could generate that but we would have to operate with N^2 edges, which is not feasible.

## BFS coloring
To find out if we can do the 2-coloring we can run BFS and always switch color as we move from node to node (if the edge is short enough to allow for communication). If we reach a node that has already been processed and has the other color than we just want to use it is clear that this graph cannot be 2-colored (is not bipartite) and we can terminate. But the main question is left unanswered - what graph should we use? We can use the graph generated by Delaunay triangulation. We know it contains the minimum spanning tree.

## The edge case
However even thou we can have valid coloring from the triangulation there still can be some edge cases when we can have an interference. So we need to do further checks. The simple way is to take each node and not only check its neighbors but also all neighbor's neighbors - they will have the same color but they should be far enough not to be able to communicate with each other. An alternative approach (which does not have a pathological case) is to create triangulation for the two subsets (by the color) and check if all the edges of the triangulation are long enough.

# Running time - neighbour checking
    Test set 1 (20 pts / 1 s) - 0.054s
    Test set 2 (30 pts / 1 s) - 0.469s
    Test set 3 (30 pts / 1 s) - 0.975s
    Test set 4 (20 pts / 1 s) - 1.021s

# Running time - triangulations
    Test set 1 (20 pts / 1 s) - 0.068s
    Test set 2 (30 pts / 1 s) - 0.876s
    Test set 3 (30 pts / 1 s) - 1.169s
    Test set 4 (20 pts / 1 s) - 1.607s
